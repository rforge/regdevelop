\name{lasso}
\title{Fit a (Generalized Linear) Model with Lasso}
\Rdversion{1.1}
\alias{lasso}
\alias{lasso.default}
\alias{lasso.formula}
\alias{lasso.lassogrp}
\description{
Functions that fit a model by (Group-) lasso, including adaptive version
}
\usage{
lasso(x, \dots)

\method{lasso}{formula}(x, data, subset, weights, na.action,
  model = "gaussian", offset, nonpen = ~1, lambda = NULL, lstep = 21,
  adaptive = FALSE, cv.function = cv.lasso,
  contrasts = NULL, save.x = TRUE, control = lassoControl(), \dots)

\method{lasso}{lassogrp}(x, lambda = NULL, lstep = 21, cv = NULL,
  cv.function = cv.lasso, save.x = TRUE,
  adaptcoef = NULL, adaptlambda = NULL, \dots)

\method{lasso}{default}(x, y, index, subset, model = "gaussian",
     lambda = NULL, lstep = 21,
% not yet supported __FIXME__  adaptive = FALSE,
% not yet supported            cv.function = cv.lasso,
     save.x = TRUE, \dots)
}
\arguments{
  \item{x}{for \code{formula} method: model formula for the
    penalized terms\cr
    for \code{default} method: design matrix, including column
    for intercept\cr
    for \code{lassogrp} method: a 'lassogrp' object i.e., the result of a first
    call to \code{lasso}
  }
  \item{data}{\code{data.frame} containing the variables in the model.}
  \item{y}{response variable (for \code{default} method)
  }
  \item{index}{a vector indicating which carriers should be penalized by
    the L1 term. This is usually obtained from calling
    \code{lassogrpModelmatrix}. See Details. (For \code{default} method)
  }
  \item{subset, weights, na.action}{as in other model fitting functions
  }
  \item{model}{type of model to be fitted: Either one of
    \describe{
      \item{"gaussian"}{ordinary linear model,}
      \item{"binomial"}{logistic regression,}
      \item{"poisson"}{Poisson regression, or}
      \item{  }{a model generated by \code{lassoModel}}
    }
  }
  \item{offset}{vector of offset values; needs to have the same length as the
        response vector. May be useful in logistic and Poisson regression.
  }
  \item{nonpen}{formula defining the model terms that must not be included in
    the lasso penalty term
  }
  \item{lambda}{vector of scaling factors of the lasso penalty term
  }
  \item{lstep}{number of lambda values to be chosen if \code{lambda} is
    not provided
  }
  \item{cv.function}{function used for cross validation}
  \item{cv}{results of cross validation, if available.
  }
  \item{adaptive}{logical: should the adaptive lasso be used?
    If TRUE, the lasso will be called twice, first in the regular mode,
    then adaptive to the results of the first call.
    (For the \code{formula} method)
  }
  \item{adaptcoef}{inverse weights for the coefficients, used for the adaptive
    lasso. By default, they are obtained as the coefficients
    of the result of an earlier call (\code{object\$coefficients}
    (for \code{lassogrp} method), or such a first call is invoked
    (for \code{formula} method).
  }
  \item{adaptlambda}{lambda value used to extract the coefficients
    for \code{adaptcoef}. Either a lambda value or a negative integer,
    in which case the coefficients corresponding to the
    \code{abs(adaptlambda)}th lambda of \code{object}.
    If \code{adaptlambda} is null, it will be selected by cross
    validation.
  }
  \item{contrasts}{an optional list. See the 'contrasts.arg' of
    'model.matrix.default'.}
  \item{save.x}{logical: should the model matrix be stored in the
    return value?}
  \item{control}{list of items to control the algorithm, see
    \code{\link{lassoControl}}}
  \item{\dots}{ further arguments, passed to \code{lassogrp}:
    \describe{
      \item{penscale}{rescaling function to adjust the value of the penalty
	parameter to the degrees of freedom of the parameter group. See the
	reference below.}
      \item{center}{logical. If true, the columns of the design matrix will be
	centered (except a possible intercept column).}
      \item{standardize}{logical. If true, the design matrix will be
	blockwise orthonormalized such that for each block \eqn{X^TX = n 1}
        (*after* possible centering).}
    }
  }
}
\details{
  The \code{index} defines the groups of carriers and whether they are
  included in the L1 penalization term.
  There is an element in \code{index} for each carrier (column of the
  model.matrix). Carriers \code{j} with positive \code{index[j]} are
  included in the penalization.
  Elements sharing the same \code{index[j]} value are a group in the
  sense of the group lasso, that is, their coefficients will be
  included in the L1 term as \code{sqrt(sum(coef^2))}.

  When using \code{grplasso.formula}, the grouping of the variables is
  derived from the type of the variables: The dummy variables of a
  factor will be automatically treated as a group.

  The lasso optimization process starts using the largest value of
  \code{lambda} as penalty parameter \eqn{\lambda}. Once
  fitted, the next largest element of \code{lambda} is used as penalty
  parameter with starting values defined as the (fitted) coefficient
  vector based on the previous component of \code{lambda}.
}
\value{A \code{"lassogrp"} object is returned, for which \code{\link{coef}},
  \code{print}, \code{plot} and \code{\link{predict}} methods exist.
  \item{coefficients}{coefficients with respect to the \emph{original} input
    variables (even if \code{standardize = TRUE} is used for fitting).}
  \item{norms.pen}{single terms of the L1 penalty term}
  \item{nloglik}{log likelihood}
  \item{fn.val}{}
  \item{fitted}{fitted values (response type)}
  \item{linear.predictors}{linear predictors}
  \item{lambda}{vector of lambda values where coefficients were calculated.}
  \item{index}{grouping index vector.}
  \item{\dots}{and further components, apply \code{\link{names}(.)} or
    \code{\link{str}(.)} to the object.}
}
\references{
  Lukas Meier, Sara van de Geer and Peter B\"uhlmann (2008),
  \emph{The Group Lasso for Logistic Regression},
  Journal of the Royal Statistical Society, \bold{70} (1), 53--71;
  \cr see also
  \url{http://stat.ethz.ch/~meier/logistic-grouplasso.php}
}
\author{Lukas Meier and Werner Stahel, \email{stahel@stat.math.ethz.ch}}

\examples{
## Lasso for asphalt example
data(asphalt)
rr <- lasso(log10(RUT) ~ log10(VISC) + ASPH+BASE+FINES+VOIDS+RUN,
            data = asphalt)
rr
names(rr)

## Use the Logistic Group Lasso on the splice data set
data(splice)

## Define a list with the contrasts of the factors
contr <- rep(list("contr.sum"), ncol(splice) - 1)
names(contr) <- names(splice)[-1]

## Fit a logistic model
fit.splice <-
  lasso(y ~ ., data = splice, model = 'binomial', lambda = 20,
  contrasts = contr)
fit.splice

## Perform the Logistic Group Lasso on a random dataset
set.seed(79)
n <- 50  ## observations
p <- 4   ## variables

## First variable (intercept) not penalized, two groups having 2 degrees
## of freedom each

index <- c(0, 2, 2, 3, 3)

## Create a random design matrix, including the intercept (first column)
x <- cbind(1, matrix(rnorm(p * n), nrow = n))
colnames(x) <- c("Intercept", paste("X", 1:4, sep = ""))

truec <- c(0, 2.1, -1.8, 0, 0)
prob <- 1 / (1 + exp(-x \%*\% truec))
mean(pmin(prob, 1 - prob)) ## Bayes risk
y <- rbinom(n, size = 1, prob = prob) ## binary response vector

## Use a multiplicative grid for the penalty parameter lambda, starting
## at the maximal lambda value
lambda <- lambdamax(x, y = y, index = index, penscale = sqrt,
                    model = LogReg()) * 0.5^(0:5)

## Fit the solution path on the lambda grid
fit <- lasso(x, y = y, index = index, lambda = lambda, model = 'binomial',
                control = lassoControl(update.hess = "lambda", trace = 0))

## Plot coefficient paths
plot(fit)
}
% Add one or more standard keywords, see file 'KEYWORDS' in the
% R documentation directory.
\keyword{models}
\keyword{regression}
